{\rtf1\ansi\ansicpg1252\cocoartf1504
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;\csgray\c100000;}
\margl1440\margr1440\vieww25400\viewh16000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 In order to make my original kwic faster, I decided to approach using parallel programming and implement multiple processes. My original kwic worked in a very linear fashion. It would first check if input exists, then creates all of the circular shifts, followed by ignoring words if that is true. After the circular shifts are created and words are ignored, list pairs is done if it is true. In my faster version of kwic, I run two separate processes in this program. I run one process for circular shifting and another process for list pairs. The reason for this is so that I can have circular shifts and list pairs working at the same time. This works by starting a new process directly after separating the lines (either by new lines or by periods, whichever is specified) and then joining the two processes right before the data needs to be returned. This substantially sped up most of my sample tests where I took random sample texts and ran list pairs on them. This resulted in speed decreases for all tests to roughly two thirds of the time compared to the original runtimes of the program. I chose these two processes (list pairs and circular shifts) for a variety of reasons. The first reason is because the two are completely independent of each other. The other process I could have chose (splitting by line) would not have worked to be simultaneously run as both of these processes depend on having a list that is comprised of the data being split up by the line. The other reason for this is because they are both extremely time intensive processes. Circular shifts require going through each line, splitting it up by word, and then creating every circular shift possibility as it can with that line. It repeats this process for every line. The list pairs optimization is where most of the magic happened. It first diverts from the main process and creates its own process called process1 that calls the worker function  list_pairs. This function is sent the data separated by lines, as well as an empty list that will be mutated. The entire purpose of this optimization was to have circular shifts and list pairs running at the same time to use up more resources and increase performance and speed. This changes the architecture of the program by making it so these two processes are running at the same time, rather then everything running in a linear fashion. }